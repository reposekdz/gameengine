import moderngl
import numpy as np
import pygame
from typing import Dict, List, Tuple, Optional
import trimesh
from OpenGL.GL import *
import math

class AdvancedRenderer:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        
        # Initialize OpenGL context
        pygame.init()
        pygame.display.set_mode((width, height), pygame.OPENGL | pygame.DOUBLEBUF)
        
        self.ctx = moderngl.create_context()
        self.ctx.enable(moderngl.DEPTH_TEST)
        self.ctx.enable(moderngl.CULL_FACE)
        
        # Shader programs
        self.programs = {}
        self._init_shaders()
        
        # Camera
        self.camera_pos = np.array([0.0, 0.0, 5.0])
        self.camera_target = np.array([0.0, 0.0, 0.0])
        self.camera_up = np.array([0.0, 1.0, 0.0])
        
        # Lighting
        self.lights = []
        self._setup_default_lighting()
        
        # Render objects
        self.render_objects = {}
        
        # Post-processing
        self.framebuffer = None
        self._setup_post_processing()
    
    def _init_shaders(self):
        \"\"\"Initialize shader programs\"\"\"\n        # Basic PBR shader\n        vertex_shader = '''\n        #version 330 core\n        \n        in vec3 in_position;\n        in vec3 in_normal;\n        in vec2 in_texcoord;\n        in vec3 in_color;\n        \n        uniform mat4 mvp_matrix;\n        uniform mat4 model_matrix;\n        uniform mat4 normal_matrix;\n        \n        out vec3 world_pos;\n        out vec3 normal;\n        out vec2 texcoord;\n        out vec3 vertex_color;\n        \n        void main() {\n            world_pos = (model_matrix * vec4(in_position, 1.0)).xyz;\n            normal = normalize((normal_matrix * vec4(in_normal, 0.0)).xyz);\n            texcoord = in_texcoord;\n            vertex_color = in_color;\n            \n            gl_Position = mvp_matrix * vec4(in_position, 1.0);\n        }\n        '''\n        \n        fragment_shader = '''\n        #version 330 core\n        \n        in vec3 world_pos;\n        in vec3 normal;\n        in vec2 texcoord;\n        in vec3 vertex_color;\n        \n        uniform vec3 camera_pos;\n        uniform vec3 light_pos;\n        uniform vec3 light_color;\n        uniform float light_intensity;\n        \n        uniform vec3 material_albedo;\n        uniform float material_metallic;\n        uniform float material_roughness;\n        uniform float material_ao;\n        \n        out vec4 fragColor;\n        \n        vec3 calculatePBR(vec3 albedo, float metallic, float roughness, vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor) {\n            vec3 F0 = mix(vec3(0.04), albedo, metallic);\n            vec3 halfwayDir = normalize(lightDir + viewDir);\n            \n            float NdotV = max(dot(normal, viewDir), 0.0);\n            float NdotL = max(dot(normal, lightDir), 0.0);\n            float HdotV = max(dot(halfwayDir, viewDir), 0.0);\n            float NdotH = max(dot(normal, halfwayDir), 0.0);\n            \n            // Fresnel\n            vec3 F = F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);\n            \n            // Distribution\n            float alpha = roughness * roughness;\n            float alpha2 = alpha * alpha;\n            float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0;\n            float D = alpha2 / (3.14159265 * denom * denom);\n            \n            // Geometry\n            float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n            float G1L = NdotL / (NdotL * (1.0 - k) + k);\n            float G1V = NdotV / (NdotV * (1.0 - k) + k);\n            float G = G1L * G1V;\n            \n            // BRDF\n            vec3 numerator = D * G * F;\n            float denominator = 4.0 * NdotV * NdotL + 0.001;\n            vec3 specular = numerator / denominator;\n            \n            vec3 kS = F;\n            vec3 kD = vec3(1.0) - kS;\n            kD *= 1.0 - metallic;\n            \n            return (kD * albedo / 3.14159265 + specular) * lightColor * NdotL;\n        }\n        \n        void main() {\n            vec3 albedo = material_albedo * vertex_color;\n            \n            vec3 viewDir = normalize(camera_pos - world_pos);\n            vec3 lightDir = normalize(light_pos - world_pos);\n            \n            vec3 color = calculatePBR(albedo, material_metallic, material_roughness, normal, viewDir, lightDir, light_color * light_intensity);\n            \n            // Ambient\n            vec3 ambient = vec3(0.03) * albedo * material_ao;\n            color += ambient;\n            \n            // Tone mapping\n            color = color / (color + vec3(1.0));\n            \n            // Gamma correction\n            color = pow(color, vec3(1.0/2.2));\n            \n            fragColor = vec4(color, 1.0);\n        }\n        '''\n        \n        self.programs['pbr'] = self.ctx.program(vertex_shader=vertex_shader, fragment_shader=fragment_shader)\n        \n        # Skybox shader\n        skybox_vertex = '''\n        #version 330 core\n        in vec3 in_position;\n        uniform mat4 view_matrix;\n        uniform mat4 projection_matrix;\n        out vec3 texCoords;\n        \n        void main() {\n            texCoords = in_position;\n            vec4 pos = projection_matrix * view_matrix * vec4(in_position, 1.0);\n            gl_Position = pos.xyww;\n        }\n        '''\n        \n        skybox_fragment = '''\n        #version 330 core\n        in vec3 texCoords;\n        out vec4 fragColor;\n        \n        void main() {\n            vec3 color = mix(vec3(0.5, 0.7, 1.0), vec3(0.1, 0.1, 0.2), normalize(texCoords).y * 0.5 + 0.5);\n            fragColor = vec4(color, 1.0);\n        }\n        '''\n        \n        self.programs['skybox'] = self.ctx.program(vertex_shader=skybox_vertex, fragment_shader=skybox_fragment)\n    \n    def _setup_default_lighting(self):\n        \"\"\"Setup default lighting\"\"\"\n        self.lights = [\n            {\n                'position': np.array([5.0, 5.0, 5.0]),\n                'color': np.array([1.0, 1.0, 1.0]),\n                'intensity': 10.0\n            },\n            {\n                'position': np.array([-5.0, 3.0, 2.0]),\n                'color': np.array([0.8, 0.9, 1.0]),\n                'intensity': 5.0\n            }\n        ]\n    \n    def _setup_post_processing(self):\n        \"\"\"Setup post-processing pipeline\"\"\"\n        # Create framebuffer for post-processing\n        self.color_texture = self.ctx.texture((self.width, self.height), 4)\n        self.depth_texture = self.ctx.depth_texture((self.width, self.height))\n        self.framebuffer = self.ctx.framebuffer(color_attachments=[self.color_texture], depth_attachment=self.depth_texture)\n        \n        # Post-processing quad\n        quad_vertices = np.array([\n            -1.0, -1.0, 0.0, 0.0,\n             1.0, -1.0, 1.0, 0.0,\n             1.0,  1.0, 1.0, 1.0,\n            -1.0,  1.0, 0.0, 1.0\n        ], dtype=np.float32)\n        \n        quad_indices = np.array([0, 1, 2, 0, 2, 3], dtype=np.uint32)\n        \n        self.quad_vbo = self.ctx.buffer(quad_vertices.tobytes())\n        self.quad_ibo = self.ctx.buffer(quad_indices.tobytes())\n        self.quad_vao = self.ctx.vertex_array(self.programs['pbr'], [(self.quad_vbo, '2f 2f', 'in_position', 'in_texcoord')])\n    \n    def add_mesh(self, mesh_id: str, mesh: trimesh.Trimesh, material: Optional[Dict] = None):\n        \"\"\"Add mesh to renderer\"\"\"\n        if material is None:\n            material = {\n                'albedo': [0.7, 0.7, 0.7],\n                'metallic': 0.0,\n                'roughness': 0.5,\n                'ao': 1.0\n            }\n        \n        # Prepare vertex data\n        vertices = mesh.vertices.astype(np.float32)\n        normals = mesh.vertex_normals.astype(np.float32)\n        \n        # Generate texture coordinates if not present\n        if hasattr(mesh.visual, 'uv') and mesh.visual.uv is not None:\n            texcoords = mesh.visual.uv.astype(np.float32)\n        else:\n            # Generate spherical UV coordinates\n            texcoords = self._generate_spherical_uv(vertices)\n        \n        # Get vertex colors\n        if hasattr(mesh.visual, 'vertex_colors') and mesh.visual.vertex_colors is not None:\n            colors = mesh.visual.vertex_colors[:, :3].astype(np.float32) / 255.0\n        else:\n            colors = np.ones((len(vertices), 3), dtype=np.float32) * 0.7\n        \n        # Interleave vertex data\n        vertex_data = np.column_stack([vertices, normals, texcoords, colors]).astype(np.float32)\n        \n        # Create buffers\n        vbo = self.ctx.buffer(vertex_data.tobytes())\n        ibo = self.ctx.buffer(mesh.faces.astype(np.uint32).tobytes())\n        \n        # Create VAO\n        vao = self.ctx.vertex_array(\n            self.programs['pbr'],\n            [(vbo, '3f 3f 2f 3f', 'in_position', 'in_normal', 'in_texcoord', 'in_color')],\n            ibo\n        )\n        \n        self.render_objects[mesh_id] = {\n            'vao': vao,\n            'material': material,\n            'transform': np.eye(4),\n            'face_count': len(mesh.faces)\n        }\n    \n    def _generate_spherical_uv(self, vertices: np.ndarray) -> np.ndarray:\n        \"\"\"Generate spherical UV coordinates\"\"\"\n        normalized = vertices / np.linalg.norm(vertices, axis=1, keepdims=True)\n        u = 0.5 + np.arctan2(normalized[:, 2], normalized[:, 0]) / (2 * np.pi)\n        v = 0.5 - np.arcsin(normalized[:, 1]) / np.pi\n        return np.column_stack([u, v])\n    \n    def set_camera(self, position: np.ndarray, target: np.ndarray, up: np.ndarray = None):\n        \"\"\"Set camera parameters\"\"\"\n        self.camera_pos = position\n        self.camera_target = target\n        if up is not None:\n            self.camera_up = up\n    \n    def update_object_transform(self, mesh_id: str, transform: np.ndarray):\n        \"\"\"Update object transformation matrix\"\"\"\n        if mesh_id in self.render_objects:\n            self.render_objects[mesh_id]['transform'] = transform\n    \n    def render(self):\n        \"\"\"Render the scene\"\"\"\n        # Render to framebuffer\n        self.framebuffer.use()\n        self.ctx.clear(0.1, 0.1, 0.1, 1.0)\n        self.ctx.clear(depth=1.0)\n        \n        # Calculate matrices\n        view_matrix = self._look_at(self.camera_pos, self.camera_target, self.camera_up)\n        projection_matrix = self._perspective(45.0, self.width / self.height, 0.1, 100.0)\n        \n        # Render skybox first\n        self._render_skybox(view_matrix, projection_matrix)\n        \n        # Render objects\n        for obj_id, obj in self.render_objects.items():\n            self._render_object(obj, view_matrix, projection_matrix)\n        \n        # Post-processing pass\n        self.ctx.screen.use()\n        self.ctx.clear(0.0, 0.0, 0.0, 1.0)\n        \n        # Simple blit for now (can be extended with effects)\n        self.color_texture.use(0)\n        self.quad_vao.render()\n    \n    def _render_skybox(self, view_matrix: np.ndarray, projection_matrix: np.ndarray):\n        \"\"\"Render skybox\"\"\"\n        # Create skybox cube if not exists\n        if not hasattr(self, 'skybox_vao'):\n            skybox_vertices = np.array([\n                -1.0,  1.0, -1.0, -1.0, -1.0, -1.0,  1.0, -1.0, -1.0,\n                 1.0, -1.0, -1.0,  1.0,  1.0, -1.0, -1.0,  1.0, -1.0,\n                -1.0, -1.0,  1.0, -1.0, -1.0, -1.0, -1.0,  1.0, -1.0,\n                -1.0,  1.0, -1.0, -1.0,  1.0,  1.0, -1.0, -1.0,  1.0,\n                 1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0,\n                 1.0,  1.0,  1.0,  1.0,  1.0, -1.0,  1.0, -1.0, -1.0,\n                -1.0, -1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0,  1.0,\n                 1.0,  1.0,  1.0,  1.0, -1.0,  1.0, -1.0, -1.0,  1.0,\n                -1.0,  1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0,\n                 1.0,  1.0,  1.0, -1.0,  1.0,  1.0, -1.0,  1.0, -1.0,\n                -1.0, -1.0, -1.0, -1.0, -1.0,  1.0,  1.0, -1.0, -1.0,\n                 1.0, -1.0, -1.0, -1.0, -1.0,  1.0,  1.0, -1.0,  1.0\n            ], dtype=np.float32)\n            \n            skybox_vbo = self.ctx.buffer(skybox_vertices.tobytes())\n            self.skybox_vao = self.ctx.vertex_array(self.programs['skybox'], [(skybox_vbo, '3f', 'in_position')])\n        \n        # Remove translation from view matrix\n        skybox_view = view_matrix.copy()\n        skybox_view[:3, 3] = 0\n        \n        program = self.programs['skybox']\n        program['view_matrix'].write(skybox_view.astype(np.float32).tobytes())\n        program['projection_matrix'].write(projection_matrix.astype(np.float32).tobytes())\n        \n        self.ctx.depth_func = moderngl.LEQUAL\n        self.skybox_vao.render()\n        self.ctx.depth_func = moderngl.LESS\n    \n    def _render_object(self, obj: Dict, view_matrix: np.ndarray, projection_matrix: np.ndarray):\n        \"\"\"Render individual object\"\"\"\n        program = self.programs['pbr']\n        \n        # Calculate matrices\n        model_matrix = obj['transform']\n        mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n        normal_matrix = np.linalg.inv(model_matrix).T\n        \n        # Set uniforms\n        program['mvp_matrix'].write(mvp_matrix.astype(np.float32).tobytes())\n        program['model_matrix'].write(model_matrix.astype(np.float32).tobytes())\n        program['normal_matrix'].write(normal_matrix.astype(np.float32).tobytes())\n        \n        program['camera_pos'].write(self.camera_pos.astype(np.float32).tobytes())\n        \n        # Lighting (use first light for now)\n        if self.lights:\n            light = self.lights[0]\n            program['light_pos'].write(light['position'].astype(np.float32).tobytes())\n            program['light_color'].write(light['color'].astype(np.float32).tobytes())\n            program['light_intensity'].value = light['intensity']\n        \n        # Material properties\n        material = obj['material']\n        program['material_albedo'].write(np.array(material['albedo'], dtype=np.float32).tobytes())\n        program['material_metallic'].value = material['metallic']\n        program['material_roughness'].value = material['roughness']\n        program['material_ao'].value = material['ao']\n        \n        # Render\n        obj['vao'].render()\n    \n    def _look_at(self, eye: np.ndarray, target: np.ndarray, up: np.ndarray) -> np.ndarray:\n        \"\"\"Create look-at view matrix\"\"\"\n        f = (target - eye)\n        f = f / np.linalg.norm(f)\n        \n        s = np.cross(f, up)\n        s = s / np.linalg.norm(s)\n        \n        u = np.cross(s, f)\n        \n        result = np.eye(4)\n        result[0, :3] = s\n        result[1, :3] = u\n        result[2, :3] = -f\n        result[:3, 3] = [-np.dot(s, eye), -np.dot(u, eye), np.dot(f, eye)]\n        \n        return result\n    \n    def _perspective(self, fovy: float, aspect: float, near: float, far: float) -> np.ndarray:\n        \"\"\"Create perspective projection matrix\"\"\"\n        f = 1.0 / math.tan(math.radians(fovy) / 2.0)\n        \n        result = np.zeros((4, 4))\n        result[0, 0] = f / aspect\n        result[1, 1] = f\n        result[2, 2] = (far + near) / (near - far)\n        result[2, 3] = (2.0 * far * near) / (near - far)\n        result[3, 2] = -1.0\n        \n        return result\n    \n    def cleanup(self):\n        \"\"\"Cleanup resources\"\"\"\n        for obj in self.render_objects.values():\n            obj['vao'].release()\n        \n        if hasattr(self, 'skybox_vao'):\n            self.skybox_vao.release()\n        \n        if self.framebuffer:\n            self.framebuffer.release()\n        \n        self.ctx.release()