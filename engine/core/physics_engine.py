import numpy as np
from typing import Dict, List, Tuple, Optional, Callable
from dataclasses import dataclass
import trimesh
from scipy.spatial.distance import cdist
from scipy.integrate import odeint
import threading
import time

@dataclass
class RigidBody:
    position: np.ndarray
    velocity: np.ndarray
    acceleration: np.ndarray
    rotation: np.ndarray  # Quaternion
    angular_velocity: np.ndarray
    angular_acceleration: np.ndarray
    mass: float
    inertia_tensor: np.ndarray
    restitution: float
    friction: float
    is_static: bool
    mesh: Optional[trimesh.Trimesh]
    bounding_box: Optional[Tuple[np.ndarray, np.ndarray]]

@dataclass
class Collision:
    body1_id: str
    body2_id: str
    contact_point: np.ndarray
    contact_normal: np.ndarray
    penetration_depth: float
    relative_velocity: np.ndarray

class PhysicsEngine:
    def __init__(self, gravity: np.ndarray = np.array([0.0, -9.81, 0.0])):
        self.gravity = gravity
        self.bodies: Dict[str, RigidBody] = {}
        self.constraints = []
        self.collision_pairs = []
        
        # Simulation parameters
        self.time_step = 1.0 / 60.0
        self.max_iterations = 10
        self.position_correction = 0.8
        self.velocity_threshold = 0.01
        
        # Spatial partitioning
        self.spatial_grid = {}
        self.grid_size = 2.0
        
        # Threading
        self.running = False
        self.physics_thread = None
        self.lock = threading.Lock()
        
        # Callbacks
        self.collision_callbacks: List[Callable] = []
    
    def add_rigid_body(self, body_id: str, mesh: trimesh.Trimesh, 
                      position: np.ndarray = np.zeros(3),
                      velocity: np.ndarray = np.zeros(3),
                      mass: float = 1.0,
                      restitution: float = 0.5,
                      friction: float = 0.5,
                      is_static: bool = False) -> str:
        \"\"\"Add rigid body to physics simulation\"\"\"\n        \n        # Calculate inertia tensor from mesh\n        if not is_static and mesh is not None:\n            inertia_tensor = self._calculate_inertia_tensor(mesh, mass)\n        else:\n            inertia_tensor = np.eye(3)\n        \n        # Calculate bounding box\n        if mesh is not None:\n            bbox_min = mesh.bounds[0]\n            bbox_max = mesh.bounds[1]\n            bounding_box = (bbox_min, bbox_max)\n        else:\n            bounding_box = None\n        \n        body = RigidBody(\n            position=position.copy(),\n            velocity=velocity.copy(),\n            acceleration=np.zeros(3),\n            rotation=np.array([0.0, 0.0, 0.0, 1.0]),  # Identity quaternion\n            angular_velocity=np.zeros(3),\n            angular_acceleration=np.zeros(3),\n            mass=mass,\n            inertia_tensor=inertia_tensor,\n            restitution=restitution,\n            friction=friction,\n            is_static=is_static,\n            mesh=mesh,\n            bounding_box=bounding_box\n        )\n        \n        with self.lock:\n            self.bodies[body_id] = body\n        \n        return body_id\n    \n    def _calculate_inertia_tensor(self, mesh: trimesh.Trimesh, mass: float) -> np.ndarray:\n        \"\"\"Calculate inertia tensor for mesh\"\"\"\n        if mesh.is_watertight:\n            # Use mesh moments for accurate calculation\n            try:\n                moments = mesh.moment_inertia\n                return moments * mass / mesh.mass\n            except:\n                pass\n        \n        # Fallback: approximate as box\n        extents = mesh.bounds[1] - mesh.bounds[0]\n        w, h, d = extents\n        \n        Ixx = mass * (h*h + d*d) / 12.0\n        Iyy = mass * (w*w + d*d) / 12.0\n        Izz = mass * (w*w + h*h) / 12.0\n        \n        return np.diag([Ixx, Iyy, Izz])\n    \n    def apply_force(self, body_id: str, force: np.ndarray, point: Optional[np.ndarray] = None):\n        \"\"\"Apply force to rigid body\"\"\"\n        if body_id not in self.bodies:\n            return\n        \n        body = self.bodies[body_id]\n        if body.is_static:\n            return\n        \n        with self.lock:\n            # Linear force\n            body.acceleration += force / body.mass\n            \n            # Torque if point is specified\n            if point is not None:\n                r = point - body.position\n                torque = np.cross(r, force)\n                angular_acc = np.linalg.solve(body.inertia_tensor, torque)\n                body.angular_acceleration += angular_acc\n    \n    def apply_impulse(self, body_id: str, impulse: np.ndarray, point: Optional[np.ndarray] = None):\n        \"\"\"Apply impulse to rigid body\"\"\"\n        if body_id not in self.bodies:\n            return\n        \n        body = self.bodies[body_id]\n        if body.is_static:\n            return\n        \n        with self.lock:\n            # Linear impulse\n            body.velocity += impulse / body.mass\n            \n            # Angular impulse if point is specified\n            if point is not None:\n                r = point - body.position\n                angular_impulse = np.cross(r, impulse)\n                angular_velocity_change = np.linalg.solve(body.inertia_tensor, angular_impulse)\n                body.angular_velocity += angular_velocity_change\n    \n    def set_position(self, body_id: str, position: np.ndarray):\n        \"\"\"Set body position\"\"\"\n        if body_id in self.bodies:\n            with self.lock:\n                self.bodies[body_id].position = position.copy()\n    \n    def set_velocity(self, body_id: str, velocity: np.ndarray):\n        \"\"\"Set body velocity\"\"\"\n        if body_id in self.bodies:\n            with self.lock:\n                self.bodies[body_id].velocity = velocity.copy()\n    \n    def get_transform_matrix(self, body_id: str) -> np.ndarray:\n        \"\"\"Get transformation matrix for body\"\"\"\n        if body_id not in self.bodies:\n            return np.eye(4)\n        \n        body = self.bodies[body_id]\n        \n        # Convert quaternion to rotation matrix\n        q = body.rotation\n        rotation_matrix = self._quaternion_to_matrix(q)\n        \n        # Create transformation matrix\n        transform = np.eye(4)\n        transform[:3, :3] = rotation_matrix\n        transform[:3, 3] = body.position\n        \n        return transform\n    \n    def _quaternion_to_matrix(self, q: np.ndarray) -> np.ndarray:\n        \"\"\"Convert quaternion to rotation matrix\"\"\"\n        x, y, z, w = q\n        \n        return np.array([\n            [1 - 2*(y*y + z*z), 2*(x*y - z*w), 2*(x*z + y*w)],\n            [2*(x*y + z*w), 1 - 2*(x*x + z*z), 2*(y*z - x*w)],\n            [2*(x*z - y*w), 2*(y*z + x*w), 1 - 2*(x*x + y*y)]\n        ])\n    \n    def start_simulation(self):\n        \"\"\"Start physics simulation thread\"\"\"\n        if not self.running:\n            self.running = True\n            self.physics_thread = threading.Thread(target=self._simulation_loop)\n            self.physics_thread.start()\n    \n    def stop_simulation(self):\n        \"\"\"Stop physics simulation\"\"\"\n        self.running = False\n        if self.physics_thread:\n            self.physics_thread.join()\n    \n    def _simulation_loop(self):\n        \"\"\"Main physics simulation loop\"\"\"\n        last_time = time.time()\n        \n        while self.running:\n            current_time = time.time()\n            dt = current_time - last_time\n            \n            if dt >= self.time_step:\n                self._step_simulation(dt)\n                last_time = current_time\n            else:\n                time.sleep(0.001)  # Small sleep to prevent busy waiting\n    \n    def _step_simulation(self, dt: float):\n        \"\"\"Single physics simulation step\"\"\"\n        with self.lock:\n            # Update spatial partitioning\n            self._update_spatial_grid()\n            \n            # Broad phase collision detection\n            potential_collisions = self._broad_phase_collision_detection()\n            \n            # Narrow phase collision detection\n            collisions = self._narrow_phase_collision_detection(potential_collisions)\n            \n            # Resolve collisions\n            for _ in range(self.max_iterations):\n                if not self._resolve_collisions(collisions):\n                    break\n            \n            # Integrate forces and update positions\n            self._integrate_bodies(dt)\n            \n            # Call collision callbacks\n            for collision in collisions:\n                for callback in self.collision_callbacks:\n                    callback(collision)\n    \n    def _update_spatial_grid(self):\n        \"\"\"Update spatial partitioning grid\"\"\"\n        self.spatial_grid.clear()\n        \n        for body_id, body in self.bodies.items():\n            if body.bounding_box is None:\n                continue\n            \n            bbox_min, bbox_max = body.bounding_box\n            bbox_min += body.position\n            bbox_max += body.position\n            \n            # Find grid cells that the bounding box overlaps\n            min_cell = np.floor(bbox_min / self.grid_size).astype(int)\n            max_cell = np.floor(bbox_max / self.grid_size).astype(int)\n            \n            for x in range(min_cell[0], max_cell[0] + 1):\n                for y in range(min_cell[1], max_cell[1] + 1):\n                    for z in range(min_cell[2], max_cell[2] + 1):\n                        cell = (x, y, z)\n                        if cell not in self.spatial_grid:\n                            self.spatial_grid[cell] = []\n                        self.spatial_grid[cell].append(body_id)\n    \n    def _broad_phase_collision_detection(self) -> List[Tuple[str, str]]:\n        \"\"\"Broad phase collision detection using spatial grid\"\"\"\n        potential_pairs = set()\n        \n        for cell_bodies in self.spatial_grid.values():\n            for i in range(len(cell_bodies)):\n                for j in range(i + 1, len(cell_bodies)):\n                    body1_id, body2_id = cell_bodies[i], cell_bodies[j]\n                    \n                    # Skip if both bodies are static\n                    if self.bodies[body1_id].is_static and self.bodies[body2_id].is_static:\n                        continue\n                    \n                    pair = tuple(sorted([body1_id, body2_id]))\n                    potential_pairs.add(pair)\n        \n        return list(potential_pairs)\n    \n    def _narrow_phase_collision_detection(self, potential_pairs: List[Tuple[str, str]]) -> List[Collision]:\n        \"\"\"Narrow phase collision detection\"\"\"\n        collisions = []\n        \n        for body1_id, body2_id in potential_pairs:\n            body1 = self.bodies[body1_id]\n            body2 = self.bodies[body2_id]\n            \n            # Simple bounding box collision for now\n            collision = self._check_bounding_box_collision(body1, body2)\n            if collision:\n                collisions.append(Collision(\n                    body1_id=body1_id,\n                    body2_id=body2_id,\n                    contact_point=collision['contact_point'],\n                    contact_normal=collision['contact_normal'],\n                    penetration_depth=collision['penetration_depth'],\n                    relative_velocity=body1.velocity - body2.velocity\n                ))\n        \n        return collisions\n    \n    def _check_bounding_box_collision(self, body1: RigidBody, body2: RigidBody) -> Optional[Dict]:\n        \"\"\"Check collision between two bounding boxes\"\"\"\n        if body1.bounding_box is None or body2.bounding_box is None:\n            return None\n        \n        bbox1_min = body1.bounding_box[0] + body1.position\n        bbox1_max = body1.bounding_box[1] + body1.position\n        bbox2_min = body2.bounding_box[0] + body2.position\n        bbox2_max = body2.bounding_box[1] + body2.position\n        \n        # Check for overlap\n        if (bbox1_max[0] < bbox2_min[0] or bbox1_min[0] > bbox2_max[0] or\n            bbox1_max[1] < bbox2_min[1] or bbox1_min[1] > bbox2_max[1] or\n            bbox1_max[2] < bbox2_min[2] or bbox1_min[2] > bbox2_max[2]):\n            return None\n        \n        # Calculate collision details\n        overlap = np.minimum(bbox1_max, bbox2_max) - np.maximum(bbox1_min, bbox2_min)\n        min_overlap_axis = np.argmin(overlap)\n        \n        contact_normal = np.zeros(3)\n        contact_normal[min_overlap_axis] = 1.0 if body1.position[min_overlap_axis] < body2.position[min_overlap_axis] else -1.0\n        \n        contact_point = (np.maximum(bbox1_min, bbox2_min) + np.minimum(bbox1_max, bbox2_max)) / 2\n        penetration_depth = overlap[min_overlap_axis]\n        \n        return {\n            'contact_point': contact_point,\n            'contact_normal': contact_normal,\n            'penetration_depth': penetration_depth\n        }\n    \n    def _resolve_collisions(self, collisions: List[Collision]) -> bool:\n        \"\"\"Resolve collisions using impulse-based method\"\"\"\n        resolved_any = False\n        \n        for collision in collisions:\n            body1 = self.bodies[collision.body1_id]\n            body2 = self.bodies[collision.body2_id]\n            \n            if body1.is_static and body2.is_static:\n                continue\n            \n            # Position correction\n            if collision.penetration_depth > 0.01:  # Threshold to avoid jitter\n                correction = collision.contact_normal * collision.penetration_depth * self.position_correction\n                \n                if not body1.is_static and not body2.is_static:\n                    mass_sum = body1.mass + body2.mass\n                    body1.position -= correction * (body2.mass / mass_sum)\n                    body2.position += correction * (body1.mass / mass_sum)\n                elif not body1.is_static:\n                    body1.position -= correction\n                elif not body2.is_static:\n                    body2.position += correction\n                \n                resolved_any = True\n            \n            # Velocity resolution\n            relative_velocity = np.dot(collision.relative_velocity, collision.contact_normal)\n            \n            if relative_velocity > 0:  # Objects separating\n                continue\n            \n            # Calculate impulse\n            restitution = min(body1.restitution, body2.restitution)\n            impulse_magnitude = -(1 + restitution) * relative_velocity\n            \n            if not body1.is_static and not body2.is_static:\n                impulse_magnitude /= (1/body1.mass + 1/body2.mass)\n            elif not body1.is_static:\n                impulse_magnitude /= (1/body1.mass)\n            elif not body2.is_static:\n                impulse_magnitude /= (1/body2.mass)\n            \n            impulse = collision.contact_normal * impulse_magnitude\n            \n            # Apply impulse\n            if not body1.is_static:\n                body1.velocity += impulse / body1.mass\n            if not body2.is_static:\n                body2.velocity -= impulse / body2.mass\n            \n            resolved_any = True\n        \n        return resolved_any\n    \n    def _integrate_bodies(self, dt: float):\n        \"\"\"Integrate body positions and rotations\"\"\"\n        for body in self.bodies.values():\n            if body.is_static:\n                continue\n            \n            # Apply gravity\n            body.acceleration += self.gravity\n            \n            # Integrate linear motion\n            body.velocity += body.acceleration * dt\n            body.position += body.velocity * dt\n            \n            # Apply damping\n            body.velocity *= 0.999\n            body.angular_velocity *= 0.999\n            \n            # Integrate angular motion\n            body.angular_velocity += body.angular_acceleration * dt\n            \n            # Update rotation (simplified)\n            if np.linalg.norm(body.angular_velocity) > 0.001:\n                angle = np.linalg.norm(body.angular_velocity) * dt\n                axis = body.angular_velocity / np.linalg.norm(body.angular_velocity)\n                \n                # Convert to quaternion rotation\n                rotation_quat = np.array([\n                    axis[0] * np.sin(angle/2),\n                    axis[1] * np.sin(angle/2),\n                    axis[2] * np.sin(angle/2),\n                    np.cos(angle/2)\n                ])\n                \n                # Multiply quaternions (simplified)\n                body.rotation = self._multiply_quaternions(rotation_quat, body.rotation)\n                body.rotation /= np.linalg.norm(body.rotation)  # Normalize\n            \n            # Reset accelerations\n            body.acceleration = np.zeros(3)\n            body.angular_acceleration = np.zeros(3)\n    \n    def _multiply_quaternions(self, q1: np.ndarray, q2: np.ndarray) -> np.ndarray:\n        \"\"\"Multiply two quaternions\"\"\"\n        x1, y1, z1, w1 = q1\n        x2, y2, z2, w2 = q2\n        \n        return np.array([\n            w1*x2 + x1*w2 + y1*z2 - z1*y2,\n            w1*y2 - x1*z2 + y1*w2 + z1*x2,\n            w1*z2 + x1*y2 - y1*x2 + z1*w2,\n            w1*w2 - x1*x2 - y1*y2 - z1*z2\n        ])\n    \n    def add_collision_callback(self, callback: Callable[[Collision], None]):\n        \"\"\"Add collision callback function\"\"\"\n        self.collision_callbacks.append(callback)\n    \n    def remove_body(self, body_id: str):\n        \"\"\"Remove body from simulation\"\"\"\n        with self.lock:\n            if body_id in self.bodies:\n                del self.bodies[body_id]